#           the landmark 
    # the landmark will be generated by facemesh, usually in this structure [x,y,z].
    # if z is negative, the point is closer to the camera and vice-versa.
    # the value of the x and y which is the co-ordinate location of each pixel,has been normalized from 0 to 1
    # meaning if the value of x = 0.7, it means 70% of the width of the image
    # if a frame is 1080*1920, then the x value of 0.7 will be 0.7*1920 = 1344
    # and if y = 0.5, it means 50% of the height of the image
    # if a frame is 1080*1920, then the y value of 0.5 will be 0.5*1080 = 540
    # from this we know the precise location of that landmark in the eye
import cv2 
import mediapipe as mp
import numpy as np
import time

class EyeTracker:
    def __init__(self):
        self.mp_face_mesh = mp.solutions.face_mesh
        self.cap = cv2.VideoCapture(0)
        self.left_iris = [474, 475, 476, 477]
        self.right_iris = [469, 470, 471, 472]
        self.face_mesh = self.mp_face_mesh.FaceMesh(
            max_num_faces=1,
            refine_landmarks=True,
            min_detection_confidence=0.5,
            min_tracking_confidence=0.5
        )
        self.away_start_time = None
        self.away_flagged = False
        self.no_face_start_time = None
        self.no_face_flagged = False

    def locate_pupil(self, landmarks, eye_index, image_width, Image_height):
        pupils_co_ordinates = []
        for i in eye_index:
            x = int(landmarks.landmark[i].x * image_width)
            y = int(landmarks.landmark[i].y * Image_height)
            pupils_co_ordinates.append((x, y))
        if pupils_co_ordinates:
            pcx = int(np.mean([i[0] for i in pupils_co_ordinates]))
            pcy = int(np.mean([i[1] for i in pupils_co_ordinates]))
            return pcx, pcy
        return None, None

    def locate_gaze_direction(self, left_eye_x, right_eye_x, frame_width):
        eye_avg_x = (left_eye_x + right_eye_x) / 2
        now = time.time()

        # If already flagged for looking away, keep returning the flagged message until gaze is centered
        if self.away_flagged:
            if frame_width * 0.45 <= eye_avg_x <= frame_width * 0.65:
                self.away_flagged = False
                self.away_start_time = None
            else:
                return "Flagged: Looking away for 3+ seconds"

        # Check if looking away (left or right)
        if eye_avg_x < frame_width * 0.45 or eye_avg_x > frame_width * 0.65:
            if self.away_start_time is None:
                self.away_start_time = now
            elif now - self.away_start_time >= 3:
                self.away_flagged = True
                return "Flagged: Looking away for 3+ seconds"
        else:
            self.away_start_time = None

        # Normal gaze direction logic
        if eye_avg_x < frame_width * 0.45:
            return "looking right"
        elif eye_avg_x > frame_width * 0.65:
            return "Looking left"
        else:
            return "Looking Center"

    def process_frame(self, frame):
        image_height, image_width, _ = frame.shape
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_mesh.process(frame_rgb)
        now = time.time()

        if results.multi_face_landmarks:
            # Face detected, reset no-face flag
            self.no_face_start_time = None
            self.no_face_flagged = False
            for landmarks in results.multi_face_landmarks:
                left_eye_x, left_eye_y = self.locate_pupil(landmarks, self.left_iris, image_width, image_height)
                right_eye_x, right_eye_y = self.locate_pupil(landmarks, self.right_iris, image_width, image_height)
                if left_eye_x and right_eye_x:
                    direction = self.locate_gaze_direction(left_eye_x, right_eye_x, image_width)
                    return {"direction": direction}
            # If landmarks exist but eyes can't be tracked, treat as no face
            if not self.no_face_flagged:
                if self.no_face_start_time is None:
                    self.no_face_start_time = now
                elif now - self.no_face_start_time >= 3:
                    self.no_face_flagged = True
                    return {"direction": "Flagged: Looking away for 3+ seconds"}
            return {"direction": "No face detected"}
        else:
            # No face detected
            if not self.no_face_flagged:
                if self.no_face_start_time is None:
                    self.no_face_start_time = now
                elif now - self.no_face_start_time >= 3:
                    self.no_face_flagged = True
                    return {"direction": "Flagged: Looking away for 3+ seconds"}
                return {"direction": "No face detected"}
            else:
                return {"direction": "Flagged: Looking away for 3+ seconds"}