    #           the landmark 
    # the landmark will be generated by facemesh, usually in this structure [x,y,z].
    # if z is negative, the point is closer to the camera and vice-versa.
    # the value of the x and y which is the co-ordinate location of each pixel,has been normalized from 0 to 1
    # meaning if the value of x = 0.7, it means 70% of the width of the image
    # if a frame is 1080*1920, then the x value of 0.7 will be 0.7*1920 = 1344
    # and if y = 0.5, it means 50% of the height of the image
    # if a frame is 1080*1920, then the y value of 0.5 will be 0.5*1080 = 540
    # from this we know the precise location of that landmark in the eye
import cv2 
import mediapipe as mp
import numpy as np


class EyeTracker:
    def __init__(self):
        self.mp_face_mesh = mp.solutions.face_mesh
        self.cap = cv2.VideoCapture(0)
        self.left_iris= [474,475,476,477]
        self.right_iris= [469,470,471,472]
        self.face_mesh = self.mp_face_mesh.FaceMesh(
                max_num_faces=1,
                refine_landmarks=True,
                min_detection_confidence=0.5,
                min_tracking_confidence=0.5
                )
        
    def locate_pupil(self, landmarks, eye_index, image_width, Image_height):

        pupils_co_ordinates = [] # 4 values will be here [(234,124), (334,224), (434,324), (534,424)]
        for i in eye_index:
            x = int(landmarks.landmark[i].x * image_width)
            y = int(landmarks.landmark[i].y * Image_height)
            pupils_co_ordinates.append((x,y))
        if pupils_co_ordinates:
            pcx = int(np.mean([i[0] for i in pupils_co_ordinates]))
            pcy = int(np.mean([i[1] for i in pupils_co_ordinates]))
            return pcx, pcy
        return None, None

# revisit
    def locate_gaze_direction(self, left_eye_x, right_eye_x, frame_width):
        # the average of the two eyes will be taken to determine the gaze direction
        eye_avg_x = (left_eye_x + right_eye_x) / 2
        if eye_avg_x < frame_width * 0.3:
            return "Looking Left"
        elif eye_avg_x > frame_width * 0.7:
            return "Looking Right"
        else:
            return "Looking Center"
        
# while cap.isOpened():
#     ret, frame = cap.read()
#     if not ret:
#         break
    def process_frame(self, frame):
        image_height, image_width, _ = frame.shape
        # print(f"Frame Width: {image_width}, Frame Height: {image_height}")
        
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        # process the frame using face mesh to get all 478 landmarks
        results = self.face_mesh.process(frame_rgb)
        
        if results.multi_face_landmarks:
            for landmarks in results.multi_face_landmarks:
                # Get iris centers (pupils)
                left_eye_x, left_eye_y = self.locate_pupil(landmarks, self.left_iris, image_width, image_height)
                right_eye_x, right_eye_y = self.locate_pupil(landmarks, self.right_iris, image_width, image_height)
                               
                if left_eye_x and right_eye_x:
                    direction = self.locate_gaze_direction(left_eye_x, right_eye_x, image_width)
                    return {"direction": direction}
        return {"direction": "No face detected"}
